/*
    Modificado por Igor de Andrade Junqueira,
    comentario original:

    Safe C++, Or How to Avoid Most Common Mistakes in C++ Code by Vladimir Kushnir, (OÃ•Reilly).
    Copyright 2012 Vladimir Kushnir, ISBN 9781449320935.
    If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at permissions@oreilly.com.
*/

#ifndef TTP_SAFE_VECTOR_H
#define TTP_SAFE_VECTOR_H

#include "iostream"
#include <vector>
#include <ostream>

// Wrapper around std::vector, has temporary sanity checks in the operators [].
template <typename T>
class Vector : public std::vector<T>
{
public:

    // Most commonly used constructors:
    explicit Vector(size_t n = 0): std::vector<T>(n){}

    Vector(size_t n, const T& value): std::vector<T>(n, value){}

    template <class InputIterator> Vector (InputIterator first, InputIterator last): std::vector<T>(first, last){}

    // Note: we do not provide a copy-ctor and assignment operator.
    // we rely on default versions of these methods generated by the compiler.

    inline __attribute__((always_inline)) T& operator[](size_t index)
    {
#if VAR_VECTOR_SANITY_CHECK
        if(index >= std::vector<T>::size())
        {
            std::cout<<"Erro indice "<<index<<" esta errado para vetor de tam "<<std::vector<T>::size()<<"\n";
            throw std::out_of_range("");
        }
#endif
        return std::vector<T>::operator[](index);
    }
    inline __attribute__((always_inline)) const T& operator[](size_t index) const
    {
#if VAR_VECTOR_SANITY_CHECK
        if(index >= std::vector<T>::size())
        {
            std::cout<<"ERRO!\n";
            throw "ERRO";
        }
#endif
        return std::vector<T>::operator[](index);
    }

    void setAll(const T& val)
    {
        for(size_t i=0; i < std::vector<T>::size(); ++i)
            std::vector<T>::operator[](i) = val;
    }

    T infNorm()const
    {
        T maior = std::abs(std::vector<T>::operator[](0));

        for(size_t i=1; i < std::vector<T>::size(); ++i)
        {
            T temp = std::abs(std::vector<T>::operator[](i));
            if(temp > maior)
                maior = temp;
        }

        return maior;
    }

    T infNormDif(const Vector<T> &vet)
    {
        T maior = std::abs(std::vector<T>::operator[](0) - vet[0]);

        for(size_t i=1; i < std::vector<T>::size(); ++i)
        {
            T temp = std::abs(std::vector<T>::operator[](i)-vet[i]);
            if(temp > maior)
                maior = temp;
        }

        return maior;
    }

    std::string printN(size_t n) const
    {
        std::string str;
        for(size_t i=0; i < n; ++i)
            str += std::to_string(std::vector<T>::operator[](i)) + " ";

        return str;
    }

};

typedef Vector<double> VectorD;
typedef Vector<int> VectorI;
typedef Vector<int64_t> VectorI64;

template <typename T>
inline __attribute__((always_inline))
std::ostream& operator << (std::ostream& os, const Vector<T>& v)
{
    for(unsigned i=0; i<v.size(); ++i) 
    {
        os << v[i];
        if(i + 1 < v.size())
            os << " ";
    }

    return os;
}


template <typename T>
inline __attribute__((always_inline))
void copiaVet(const Vector<T> &vetFonte, Vector<T> &vet, size_t tam)
{
    for(size_t i=0; i < tam; ++i)
        vet[i] = vetFonte[i];
}

#endif //TTP_SAFE_VECTOR_H
